# 编译优化文章

黄雨石

$20376156$

[toc]

## 运算强度削弱

### 乘除

* 首先对于乘法，可以将赋值操作转换为移位操作，例如将``mul $s1, $s2, num``可以翻译为：

  ```assembly
  sll $s1, $s2, x0
  sll $a1, $s2, x1
  addu $s1, $a1, $s1
  sll $a1, $s2, x3
  addu $s1, $a1, $s1
  # ...
  nge $s1, $s1 # if num < 0
  ```

  注意$|num|=2^{x_i}+2^{x_{i-1}}+...+2^{x_0}$，其中$x_i\gt x_{i-1}\gt ...\gt x_0\ge 0$，该拆分可以提前计算出来，同时需要特判$num=0$的情况，我们可以计算出这种转换所用的指令的``cycle``数，如果``cycle``数大于等于$4$，那么应该直接翻译为一条乘法指令，不然就是负优化

* 对于除法，可以参考下面的算法：

  <img src="Z:\buaa_compiler_technology_2022\szy\div_alg1.png" alt="div_alg1" style="zoom:67%;" />

  <img src="Z:\buaa_compiler_technology_2022\szy\div_alg2.png" alt="div_alg2" style="zoom:67%;" />

  当然如果对于立即数属于$\{1,-1\}$的情况特判会更快，上述算法的主要思想是将$\frac{n}{d}$转化为$\frac{n\times m}{2^{N+l}}$，即乘法加移位运算，当然还需要考虑$m$的溢出、$n$的正负性的问题

### 地址计算

对于访存一个数组的元素，比如``a[k]``，我们可以用移位运算代替乘法去计算偏移量

## 常量合并

* 对于类型为``const``或者位于全局的变量的初始值都可以在中间代码生成的过程中计算出来，于是可以写一个计算类，通过``Java``的异常机制，计算不出来那么就生成正常的中间代码
* 对于``stmt``中的一些计算语句，或者比较语句我们也可以将其算出来，但是如果遇到左值，可以用初值代替其中为``const``的变量，而非``const``变量则不行，防止变量除了初始化之外还在其它地方被赋值

对于如下代码：

```c
const int a[10] = {1,2,3,4,5,6,7,8,9,10};

int main() {
    int b = a[0] + 5;
    printf("%d", a[7] + 10);
    printf("%d", b);
    return 0;
}
```

可以翻译成如下中间代码：

```
// ...
======FUNC: main(0,1)======
DEF_VAL 6 b(1,1)
PRINT_INT 18
PRINT_INT b(1,1)
RETURN 0
======FUNC_END: main(0,1)======
```

## ``do-while``

对于``Sys``语言中的``while(cond) {...}``可以翻译成``if (cond) {do{...} while (cond)}``，即如下：

```assembly
# while
begin:
beqz cond end
...
j begin
end:

# do - while
beqz cond end
begin:
...
bnez cond begin
end:
```

对于一开始不满足情况那么二者均为跳转一次，但是如果多次进入循环体的内部，易得上面的``while``会执行$2n-1$次跳转，而下面的``do-while``会执行$n$次跳转，且不会有其他副作用，但是注意的是要翻译两次``Cond``，一次是满足要跳转``begin``，一次是不满足要跳转到``end``，这里有个问题就是如果你是解析两次``Cond``，那么如果遇到错误，你会报两次错，所以建议用一个行号为键值的``HashMap``来存储错误，这样就不会报两次同一行的错误了

## 数据流分析

### 划分基本块与流图的建立

正如在``mips``代码生成那里所说的一样，没有划分基本块，函数执行顺序信息是得不到的，只能通过一些及其不优雅的方法，例如生成空跳转来解决进入一个基本快寄存器状态不一致的问题，所以要先划分基本块并建立流图，注意这是函数内部划分，具体方法如下：

* 跳转型中间代码``JUMP``、``EQZ_JUMP``、``NEZ_JUMP``、``RETURN``的下一句作为入口点，同时除``RETURN``外，其它跳转要跳到的``LABEL``也作为入口点
* 所有入口点的前一句作为出口点，将所有代码按照入口点与出口点从小到大逐一匹配就划分完成基本块
* 将末尾为无条件跳转的基本块与其跳转到的基本块相连，注意``RETURN``算无条件跳转，且直接跳转到$B_{exit}$；其余则将自己与自己按代码顺序的下一个基本块相连，同时如果最后一条是条件跳转，那么也将它与要跳转的的基本块相连

注意在此过程进行前其实可以删除一些不必要的跳转，比如刚好要跳到的就是下一句话，或者是无条件跳转下方接一条跳转；还可以优化部分跳转，比如跳转到的``LABEL``下方恰好是一条无条件跳转，那么可以将自己跳转的``LABEL``直接变为找到的无条件跳转的``LABEL``，注意这个过程可以用递归循环找，但是要特判跳转成环的情况

在刚化完流图时，我们其实可以从所有基本块的入口开始``dfs``，遍历流图，然后将不会经过的基本块删除，这样在后续的到达定义分析，活跃变量分析得到的结果会更加准确

同时由于划分了基本块，我们可以改掉之前为使寄存器保持状态一直而生成空跳，并且在后续窥空也无法删掉它们的做法，新的做法如下：

* 在进入一个基本块前清空寄存器映射关系
* 在出基本块时，且最后一条语句不是跳转或者``RETURN``时执行完它立刻回写，如果是跳转则在跳转前回写，``RETURN``不需要回写

### 到达定义分析

注意对于数组由于较为复杂因此是不参与的，按照书本的定义$out[B]=in[B]\cup(gen[B]-kill[B])$，$in[B]=\cup_{B的前驱}out[B_{pre}]$从$B_{exit}$开始反复迭代即可，但是要注意:

* 对于一个基本块自身而言它的$kill[B]=kill[d_1]\cup kill[d_2]\cup...\cup kill[d_n]$，对于每一个$kill[d_i]$，它等于考虑的范围是这个函数的所有基本块中除了它自己之外所有中间代码
* 对于$gen[B]=gen[d_n]\cup(gen[d_{n-1}]-kill[d_n])\cup...\cup(gen[d_1]-kill[d_2]-...-kill[d_n])$，即我们可以从后往前倒着考虑每一条中间代码，如果发现该条中间代码所生成的信息已经在$gen[B]$里面了就不用添加了

### 活跃变量分析

基本上与到达定义分析相同，但是是从后往前分析，同时还有注意：

* 在计算$use[B]$的时候，数组元素不参与考虑，但是数组的下标如果是一个普通变量的话要算进来，同时函数调用的返回值也不必考虑
* $def[B]$和$use[B]$需要先统计每一个变量在基本块中第一次被定义和使用的时候，如果第一次使用的位置小于等于第一次被定义的位置，那么加入$use[B]$，否则加入$def[B]$

## 死代码删除

该优化以活跃变量分析的结果为基础：

* 首先维护一个队列$q$将基本块的$out_{active}$中的所有变量加入其中，然后倒着遍历该基本块的所有代码
* 对于当前遍历到的代码，如果它的$def$不为空，且为于$q$中或者它的$def$为空（$def$为空一定为跳转或者``printf``这种会产生副作用的代码），那么将它的$use$加入队列，同时将该$def$移除出队列；如果它的$def$不为空且不在队列中，那么则可以删掉改代码

注意对于含有对全局变量赋值意义的代码，我们不能删除，同时也要按照$def$不为空时将它的$use$加入队列处理；对于``getint``，即使他的$def$不为空且不在队列中，我们也不可以删掉，只能将它的结果由一个变量改为``(EMPTY)``，这样也省略了一条赋值语句

由于删除了很多死代码，于是也产生了很多地方可以窥孔，以至于会导致划分的基本块不再准确于是又可以重新划分基本块再优化一遍，直到优化结果不变为止

## 常量传播与复写传播

策略是常量可以跨基本块传播，变量只能块内传播，因为跨基本块前一定会回写内存，解除寄存器映射，如果跨基本块传播变量，那么极有可能需要读取内存，因此很有可能导致负优化

需要注意全局变量不能传播与被传播，因为全局变量的值可能在中间某次函数调用的时候发生改变，而我们的数据流分析并不会考虑函数调用因此需保守处理，同时数组同理也不处理，具体算法如下：

* 首先维护一个产生了$def$信息的代码的队列$q$，该队列中代码之间的顺序与它们在基本块中的顺序一致；
* 对于当前遍历到的代码，取出它的$use$信息，然后倒着遍历$q$，一旦发现$q$中有$def$的变量为$use$中的变量，那么停止遍历，
  * 同时检测该$def$的代码是否是常量赋值或者将变量定义为常量的代码，如果是那么传播常量；
  * 如果为变量赋值或者将变量定义为变量，那么接着从$q$的当前位置正向遍历，检查该变量赋值或者变量定义的代码右侧所使用的变量是否在之后被重新定义，如果没有，那么将改变量复写传播给$use$
* 如果倒着遍历完了整个队列$q$都没有可以进行的传播，且$use$变量没有出现在$q$中代码所产生的$def$信息中，那么可以检测该基本块的$in_{arrive}$中的变量，如果$use$信息中的变量只在其中出现过一次且满足上述常量传播的条件，那么可以进行跨基本块的常量传播

同样做了此优化会有很多窥空的空间，以至于会导致划分的基本块不再准确于是又可以重新划分基本块再优化一遍，直到优化结果不变为止

## 临时变量寄存器分配与回写

### $CLOCK$分配

可以使用操作系统中学过的页面分配的$CLOCK$算法：

* 维护一个指针用于遍历当前寄存器池中的寄存器
* 当要分配寄存器时，如果当前指向的寄存器为空，那么分配，同时指针指向相邻的下一个寄存器，如果不为空指针指向下一个寄存器重复之前的操作，如果一直没有空寄存器那么就直到指针回到要为变量分配寄存器时的初始位置，然后此时再循环一轮，在此轮过程中查看寄存器的脏位是否为``true``，不为``true``就分配，反之接着直到右回到要为变量分配寄存器时的初始位置，同时将该寄存器中的变量回写内存寄存器的脏位置为``false``

注意将一个变量写回内存时脏位置为``false``，``ASSIGN``、``ALU``类指令的目的寄存器的脏位置为``true``

### 引用计数

可以直接扫描中间代码中临时变量出现的次数，统计一遍，然后在翻译为``mips``的过程中记录已经使用的次数，如果已经使用的次数与出现次数相同那么在翻译当前中间代码的过程中不需要将其回写内存，同时翻译完该条中间代码就可以将该变量与寄存器的映射关系清空

## 窥孔

对于中间代码可以在删除完四代码以及做完常量传播的时候做，比如：

* 对于``ADD``的加$0$，``SUB``的减$0$，``MUL``的乘$1$，``DIV``的除$1$，``MOD``的摸$1$

* 对于跳转到的刚好是下一条句子，那么可以删除；其次：

  ```
  ASSIGN 8 a
  NEZ_JUMP a LABEL
  ```

  可以优化为：

  ```
  JUMP LABEL
  ```

  还有：

  ```
  EQZ_JUMP a LABEL1
  JUMP LABEL2
  LABEL1:
  ```

  那么可以优化为：

  ```
  NEZ_JUMP a LABEL2
  LABEL1:
  ```

  上述情况其实很多时候都会出现，如果做了短路求值，以及常量合并的情况下

* 对于进行完常量传播的代码，有的可以直接算出结果，那么也可以用一条``ASSIGN``去替代之前的计算指令，有可能在之后的再次常量传播以及死代码删除的过程中就可以被优化掉

对于目标代码可以将：

* ``move``到同一个寄存器的指令优化掉

* 连续的``sw``和``lw``如果是对于同一个寄存器和地址那么可以优化掉，比如：

  ```assembly
  sw $v0, 28($sp)
  lw $v0, 28($sp)
  
  # 或者
  lw $v0, 28($sp)
  sw $v0, 28($sp)
  ```

  第一种可以直接将两条都删掉，第二种也可以，因为按照我的架构如果回写后没有解除映射，那么只有可能是跨基本块前保存寄存器中的变量，或者是全局变量，因此考虑这两种情况均不可能会使一条``sw``前跟着一条``lw``所以可以放心大胆的删除，毕竟后面的代码会默认``$v0``此时为空了

* 如果检测到是个叶子函数，那么进入函数与离开函数时对于``$ra``寄存器的保存与恢复都可以删掉

### 无用函数调用删除

对于一些没有实际效益的函数调用我们可以直接去除关于它的调用，那么什么叫没有实际效益呢：

* 被调用函数没有返回值或者说返回值没有被用到
* 被调用函数没有对全局变量进行赋值修改
* 被调用函数没有``IO``语句，没有调用其它函数
* 调用函数传递的实参中没有数组地址

以上检查可以在语义分析生成中间代码的时候做，如果满足上述条件，那么此次函数调用可以直接在中间代码中删除